pipeline {
  agent { label 'agent-b' }

  environment {
    AWS_REGION = 'us-east-1'
  }

  stages {

    /* ================= PREPARE ================= */
    stage('Prepare') {
      steps {
        checkout scm
      }
    }

    /* ================= BUILD ================= */
    stage('Build') {
      steps {
        sh '''
          echo "Building frontend (Vite)..."
          cd app
          npm install
          chmod +x node_modules/.bin/vite
          npm run build
        '''
      }
    }

    /* ================= SETUP ================= */
    stage('Setup') {
      steps {

        /* ---- Trigger backend deploy & capture deploymentId ---- */
        script {
          def resp = sh(
            script: '''
              curl -s -X POST http://localhost:3000/api/deploy \
                -H "Content-Type: application/json" \
                -d '{"appId":"petcart"}'
            ''',
            returnStdout: true
          ).trim()

          echo "Backend response: ${resp}"

          def json = readJSON text: resp
          env.DEPLOYMENT_ID = json.deploymentId
        }

        withCredentials([
          [$class: 'AmazonWebServicesCredentialsBinding',
           credentialsId: 'account-c-aws']
        ]) {
          sh '''
            cd files/terraform
            terraform init
            terraform apply -auto-approve
          '''
        }
      }
    }

    /* ================= DEPLOY ================= */
    stage('Deploy') {
      steps {

        /* ---- Terraform Outputs ---- */
        withCredentials([
          [$class: 'AmazonWebServicesCredentialsBinding',
           credentialsId: 'account-c-aws']
        ]) {
          script {
            env.EC2_IP = sh(script: "cd files/terraform && terraform output -raw public_ip", returnStdout: true).trim()
            env.INSTANCE_ID = sh(script: "cd files/terraform && terraform output -raw instance_id", returnStdout: true).trim()
            env.NGINX_ACCESS_LOG_GROUP = sh(script: "cd files/terraform && terraform output -raw nginx_access_log_group", returnStdout: true).trim()
            env.NGINX_ERROR_LOG_GROUP = sh(script: "cd files/terraform && terraform output -raw nginx_error_log_group", returnStdout: true).trim()
          }
        }

        /* ---- Send runtime info to backend ---- */
        sh """
          curl -X POST http://localhost:3000/api/deployment/runtime \
            -H "Content-Type: application/json" \
            -d '{
              "deploymentId": "${env.DEPLOYMENT_ID}",
              "instanceId": "${env.INSTANCE_ID}",
              "accessLogGroup": "${env.NGINX_ACCESS_LOG_GROUP}",
              "errorLogGroup": "${env.NGINX_ERROR_LOG_GROUP}"
            }'
        """

        /* ---- Wait for SSH ---- */
        sh '''
          echo "Waiting for SSH on ${EC2_IP}..."
          for i in {1..30}; do
            ssh -i /home/jenkins/.ssh/hussaincloud \
                -o StrictHostKeyChecking=no \
                -o ConnectTimeout=5 \
                ec2-user@${EC2_IP} "echo SSH ready" && break
            sleep 10
          done
        '''

        /* ---- Ansible Deploy ---- */
        sh '''
          cd files/ansible

          echo "Generating inventory.ini..."
          envsubst < inventory.tpl > inventory.ini

          echo "Inventory file:"
          cat inventory.ini

          ansible-playbook -i inventory.ini deploy.yml
        '''
      }
    }

    /* ================= COMPLETE ================= */
    stage('Complete') {
      steps {
        echo "URL: http://${EC2_IP}"
        echo "INSTANCE_ID=${INSTANCE_ID}"
        echo "ACCESS_LOG_GROUP=${NGINX_ACCESS_LOG_GROUP}"
        echo "ERROR_LOG_GROUP=${NGINX_ERROR_LOG_GROUP}"
        echo "DEPLOYMENT_ID=${DEPLOYMENT_ID}"
      }
    }
  }

  post {
    always {
      cleanWs()
    }
  }
}
