pipeline {
  agent { label 'agent-b' }

  environment {
    AWS_REGION   = "us-east-1"
    CLUSTER_NAME = "petcart-eks"
    NAMESPACE    = "petcart"
    ECR_REPO     = "petcart"
  }

  parameters {
    choice(
      name: 'DEPLOY_TARGET',
      choices: ['ec2', 'eks-fargate', 'eks-ec2'],
      description: 'Choose deployment target'
    )
  }

  stages {

    stage('Checkout Repo') {
      steps {
        checkout scm
      }
    }

    stage('Prepare Scripts') {
      steps {
        sh '''
          chmod +x files/eks-fargate/scripts/*.sh || true
		  chmod +x files/eks-ec2/scripts/*.sh || true
        '''
      }
    }

    /* =======================
       EKS – FARGATE PATH
       (ALB URL + HEALTH CHECK ADDED)
       ======================= */
	   
    stage('Deploy to EKS (Fargate + ALB)') {
      when {
        expression { params.DEPLOY_TARGET == 'eks-fargate' }
      }
      steps {
        withCredentials([
          [$class: 'AmazonWebServicesCredentialsBinding',
           credentialsId: 'account-c-aws']
        ]) {
          sh '''
            set -e

            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

            aws ecr describe-repositories --repository-names ${ECR_REPO} >/dev/null 2>&1 \
              || aws ecr create-repository --repository-name ${ECR_REPO}

            aws ecr get-login-password --region ${AWS_REGION} \
              | docker login --username AWS --password-stdin \
                ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

            docker build -t ${ECR_REPO}:latest -f files/eks-fargate/docker/Dockerfile .
            docker tag ${ECR_REPO}:latest \
              ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:latest
            docker push \
              ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:latest

            eksctl create cluster -f files/eks-fargate/eksctl/cluster-fargate.yaml || true

            aws eks update-kubeconfig \
              --region ${AWS_REGION} \
              --name ${CLUSTER_NAME}

            bash files/eks-fargate/scripts/install-alb-controller.sh

            kubectl wait \
              --namespace kube-system \
              --for=condition=Available deployment/aws-load-balancer-controller \
              --timeout=300s

            kubectl apply -f files/eks-fargate/k8s/aws-observability-namespace.yaml
            bash files/eks-fargate/scripts/attach-fargate-logging-policy.sh
            kubectl apply -f files/eks-fargate/k8s/aws-logging-configmap.yaml

            kubectl apply -f files/eks-fargate/k8s/namespace.yaml
            kubectl apply -f files/eks-fargate/k8s/deployment.yaml
            kubectl apply -f files/eks-fargate/k8s/service.yaml
            kubectl apply -f files/eks-fargate/k8s/ingress.yaml

            echo "Waiting for ALB DNS (Fargate)..."
            ALB_URL=""
            for i in {1..60}; do
              ALB_URL=$(kubectl get ingress petcart-ingress -n ${NAMESPACE} \
                -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
              [ -n "$ALB_URL" ] && break
              sleep 10
            done

            if [ -z "$ALB_URL" ]; then
              echo "ERROR: ALB not created"
              exit 1
            fi

            echo "ALB URL: http://$ALB_URL"
            echo "Waiting for HTTP 200..."

            for i in {1..60}; do
              HTTP_CODE=$(curl -s --connect-timeout 5 --max-time 10 \
                -o /dev/null -w "%{http_code}" http://$ALB_URL || true)
              if [ "$HTTP_CODE" = "200" ]; then
                echo "APP LIVE (Fargate): http://$ALB_URL"
                exit 0
              fi
              sleep 10
            done

            echo "ERROR: App did not return HTTP 200"
            exit 1
          '''
        }
      }
    }

    /* =======================
       EKS – EC2 NODE GROUP PATH
       (UNCHANGED)
       ======================= */
    stage('Deploy to EKS (EC2 Node Group)') {
      when {
        expression { params.DEPLOY_TARGET == 'eks-ec2' }
      }
      steps {
        withCredentials([
          [$class: 'AmazonWebServicesCredentialsBinding',
           credentialsId: 'account-c-aws']
        ]) {
          sh '''
            set -e

            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

            aws ecr describe-repositories --repository-names ${ECR_REPO} >/dev/null 2>&1 \
              || aws ecr create-repository --repository-name ${ECR_REPO}

            aws ecr get-login-password --region ${AWS_REGION} \
              | docker login --username AWS --password-stdin \
                ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

            docker build -t ${ECR_REPO}:latest -f files/eks-ec2/docker/Dockerfile .
            docker tag ${ECR_REPO}:latest \
              ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:latest
            docker push \
              ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:latest

            eksctl create cluster -f files/eks-ec2/eksctl/cluster-nodegroup.yaml || true

            aws eks update-kubeconfig \
              --region ${AWS_REGION} \
              --name ${CLUSTER_NAME}

            kubectl wait --for=condition=Ready nodes --all --timeout=10m

            bash files/eks-ec2/scripts/install-alb-controller-ec2.sh

            kubectl rollout status deployment/aws-load-balancer-controller \
              -n kube-system --timeout=10m

            kubectl apply -f files/eks-ec2/k8s/namespace.yaml
            kubectl apply -f files/eks-ec2/k8s/deployment.yaml
            kubectl apply -f files/eks-ec2/k8s/service.yaml
            kubectl apply -f files/eks-ec2/k8s/ingress.yaml

            ALB_URL=""
            for i in {1..60}; do
              ALB_URL=$(kubectl get ingress petcart-ingress -n ${NAMESPACE} \
                -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
              [ -n "$ALB_URL" ] && break
              sleep 10
            done

            [ -z "$ALB_URL" ] && exit 1

            for i in {1..60}; do
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://$ALB_URL || true)
              [ "$HTTP_CODE" = "200" ] && exit 0
              sleep 10
            done

            exit 1
          '''
        }
      }
    }

    /* =======================
       EC2 PATH
       ======================= */
    stage('Deploy to EC2') {
      when {
        expression { params.DEPLOY_TARGET == 'ec2' }
      }
      steps {
        sh '''
          echo "Deploying application to EC2..."
        '''
      }
    }
  }

  post {
    always {
      cleanWs(deleteDirs: true, disableDeferredWipeout: true)
    }
  }
}
